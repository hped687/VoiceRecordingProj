<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Voice Recorder</title>
  <script src="lib/WebAudioRecorder.js"></script>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    button { font-size: 1.2em; padding: 0.5em 1em; }
    #status-msg { margin-top: 1em; font-weight: bold; }
    #prompt-text { margin-top: 1em; font-style: italic; color: #444; }
  </style>
</head>
<body>

  <button id="record-btn">Start Recording</button>
  
  <p id="prompt-text"></p>

<script>
let gumStream = null;
let recorder = null;
let micAccessGranted = false;

let participantId = "anon";
let questionId = "unknown_question";
let recordingPrompt = "";

const recordBtn = document.getElementById("record-btn");
const statusMsg = document.getElementById("status-msg");
const promptText = document.getElementById("prompt-text");

// Notify parent that iframe is ready
window.parent.postMessage({ type: "iframe-ready" }, "*");

// Listen for prompt/pid/qid from parent
window.addEventListener("message", (event) => {
  if (typeof event.data !== "object") return;

  const { pid, qid, prompt, type } = event.data;

  if (type === "iframe-ready") return;

  if (pid) participantId = pid;
  if (qid) questionId = qid;
  if (prompt) {
    recordingPrompt = prompt;
    promptText.textContent = `üéôÔ∏è Prompt: ${prompt}`;
  }

  statusMsg.innerText = `üé§ Ready to record QID: ${questionId}`;
});

// Handle record button
recordBtn.onclick = async function () {
  if (recordBtn.innerText === "Start Recording") {
    try {
      if (!micAccessGranted) {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micAccessGranted = true;
        gumStream = stream;
      }

      const input = new AudioContext().createMediaStreamSource(gumStream);

      recorder = new WebAudioRecorder(input, {
        workerDir: "lib/",
        encoding: "wav",
        numChannels: 1,
        onEncoderLoading: () => (statusMsg.innerText = "Loading encoder..."),
        onEncoderLoaded: () => (statusMsg.innerText = "Encoder ready. Recording..."),
      });

      recorder.setOptions({
        timeLimit: 1800,
        encodeAfterRecord: true,
      });

      recorder.onComplete = function (rec, blob) {
        statusMsg.innerText = "Recording complete. Uploading...";

        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const filename = `${participantId}_${questionId}_${timestamp}.wav`;

        const formData = new FormData();
        formData.append("file", blob, filename);

        fetch("https://qualtrics-audio-upload.onrender.com/upload", {
          method: "POST",
          body: formData,
        })
          .then(() => {
            statusMsg.innerText = "‚úÖ Uploaded successfully!";
            recordBtn.disabled = true;
          })
          .catch((error) => {
            statusMsg.innerText = "‚ùå Upload failed.";
            console.error("Upload error:", error);
          });
      };

      recorder.startRecording();
      recordBtn.innerText = "Stop Recording";
      window.parent.postMessage({ type: "start-timer" }, "*");
    } catch (err) {
      statusMsg.innerText = "‚ö†Ô∏è Microphone access denied.";
      console.error("Recording error:", err);
    }
  } else {
    try {
      recorder.finishRecording();
      if (gumStream) gumStream.getTracks().forEach((track) => track.stop());
      recordBtn.innerText = "Recording Finished";
    } catch (err) {
      statusMsg.innerText = "‚ö†Ô∏è Error stopping recording.";
      console.error(err);
    }
  }
};
</script>

</body>
</html>
