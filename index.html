<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Voice Recorder</title>

  <!-- Load the main WebAudioRecorder class -->
  <script src="lib/WebAudioRecorder.js"></script>

  <!-- Optional: CSS -->
  <style>
    body { font-family: sans-serif; padding: 2em; }
    button { font-size: 1.2em; padding: 0.5em 1em; }
    #status-msg { margin-top: 1em; font-weight: bold; }
  </style>
</head>
<body>
  <button id="record-btn">Start Recording</button>
  <p id="status-msg"></p>

  <!-- ‚úÖ This script runs AFTER WebAudioRecorder is loaded -->
  <script>
    // Get URL parameters (e.g., ?qid=Q2_open_response&pid=1234)
    const urlParams = new URLSearchParams(window.location.search);
    const qid = urlParams.get('qid') || 'unknown_question';
    const pid = urlParams.get('pid') || 'anon';

    let gumStream, recorder;
    const recordBtn = document.getElementById("record-btn");
    const statusMsg = document.getElementById("status-msg");

    recordBtn.onclick = async function () {
      if (recordBtn.innerText === "Start Recording") {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          gumStream = stream;
          const input = new AudioContext().createMediaStreamSource(stream);

          recorder = new WebAudioRecorder(input, {
            workerDir: "lib/", // relative to Netlify project
            encoding: "wav",
            numChannels: 1,
            onEncoderLoading: () => statusMsg.innerText = "Loading encoder...",
            onEncoderLoaded: () => statusMsg.innerText = "Encoder ready. Recording..."
          });

          recorder.setOptions({
            timeLimit: 1800,
            encodeAfterRecord: true
          });

         recorder.onComplete = function (rec, blob) {
  statusMsg.innerText = "Recording complete. Uploading...";

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `${pid}_${qid}_${timestamp}.wav`;

  const formData = new FormData();
formData.append("file", blob, "voice_recording.wav");
// Function to get URL params
function getParam(name) {
  const url = new URL(window.location.href);
  return url.searchParams.get(name) || "unknown";
}

// Get participant_id and question_label from URL
const participantId = getParam("participant_id");
const questionLabel = getParam("question_label");

// Build filename with timestamp
const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
const filename = `${participantId}_${questionLabel}_${timestamp}.wav`;

// üîß Add custom metadata fields
formData.append("participant_id", participantId);     // Replace with dynamic value if available
formData.append("question_label", questionlabel);           // Replace with the actual question label or ID

fetch("https://qualtrics-audio-upload.onrender.com/upload", {
  method: "POST",
  body: formData
})
  .then(() => {
    statusMsg.innerText = "‚úÖ Uploaded successfully!";
    recordBtn.disabled = true;
  })
  .catch(error => {
    statusMsg.innerText = "‚ùå Upload failed.";
    console.error("Upload error:", error);
  });

    });
};
          recorder.startRecording();
          recordBtn.innerText = "Stop Recording";

        } catch (err) {
          statusMsg.innerText = "‚ö†Ô∏è Microphone access denied.";
          console.error("Recording error:", err);
        }
      } else {
        try {
          recorder.finishRecording();
          gumStream.getTracks().forEach(track => track.stop());
          recordBtn.innerText = "Recording Finished";
        } catch (err) {
          statusMsg.innerText = "‚ö†Ô∏è Error stopping recording.";
          console.error(err);
        }
      }
    };
  </script>
</body>
</html>
